// **********************************************************************
// This file was generated by a TAF parser!
// TAF version 3.1.1.2 by WSRD Tencent.
// Generated from `./VideoCommHead.jce'
// **********************************************************************

#pragma once

#include <map>
#include <string>
#include <vector>
#include "jce/Jce.h"
using namespace std;


namespace videocomm
{
    enum JceCommonCode
    {
        SUCC = 0,
        FAIL = 1,
        ERR_TIMEOUT_PROXY = 3,
        ERR_INTERFACE_MASS_REQUEST = 4,
        ERR_FORBIDDEN = 5,
        ERR_USER_MASS_REQUEST = 6,
        ERR_DELIVER_FAIL = 8,
        ERR_SESSION_REFUSE = 9,
        ERR_INVALID_ARGUMENT = 10,
        ERR_PACKET_OVERLENGTH = 11,
        ERR_INVALID_UIN = 12,
        ERR_OUT_OF_SERVICE_UIN = 13,
        ERR_INACTIVE_UIN = 18,
        ERR_SYS_MAINTAIN = 22,
    };
    inline string etos(const JceCommonCode & e)
    {
        switch(e)
        {
            case SUCC: return "SUCC";
            case FAIL: return "FAIL";
            case ERR_TIMEOUT_PROXY: return "ERR_TIMEOUT_PROXY";
            case ERR_INTERFACE_MASS_REQUEST: return "ERR_INTERFACE_MASS_REQUEST";
            case ERR_FORBIDDEN: return "ERR_FORBIDDEN";
            case ERR_USER_MASS_REQUEST: return "ERR_USER_MASS_REQUEST";
            case ERR_DELIVER_FAIL: return "ERR_DELIVER_FAIL";
            case ERR_SESSION_REFUSE: return "ERR_SESSION_REFUSE";
            case ERR_INVALID_ARGUMENT: return "ERR_INVALID_ARGUMENT";
            case ERR_PACKET_OVERLENGTH: return "ERR_PACKET_OVERLENGTH";
            case ERR_INVALID_UIN: return "ERR_INVALID_UIN";
            case ERR_OUT_OF_SERVICE_UIN: return "ERR_OUT_OF_SERVICE_UIN";
            case ERR_INACTIVE_UIN: return "ERR_INACTIVE_UIN";
            case ERR_SYS_MAINTAIN: return "ERR_SYS_MAINTAIN";
            default: return "";
        }
    }
    inline int stoe(const string & s, JceCommonCode & e)
    {
        if(s == "SUCC")  { e=SUCC; return 0;}
        if(s == "FAIL")  { e=FAIL; return 0;}
        if(s == "ERR_TIMEOUT_PROXY")  { e=ERR_TIMEOUT_PROXY; return 0;}
        if(s == "ERR_INTERFACE_MASS_REQUEST")  { e=ERR_INTERFACE_MASS_REQUEST; return 0;}
        if(s == "ERR_FORBIDDEN")  { e=ERR_FORBIDDEN; return 0;}
        if(s == "ERR_USER_MASS_REQUEST")  { e=ERR_USER_MASS_REQUEST; return 0;}
        if(s == "ERR_DELIVER_FAIL")  { e=ERR_DELIVER_FAIL; return 0;}
        if(s == "ERR_SESSION_REFUSE")  { e=ERR_SESSION_REFUSE; return 0;}
        if(s == "ERR_INVALID_ARGUMENT")  { e=ERR_INVALID_ARGUMENT; return 0;}
        if(s == "ERR_PACKET_OVERLENGTH")  { e=ERR_PACKET_OVERLENGTH; return 0;}
        if(s == "ERR_INVALID_UIN")  { e=ERR_INVALID_UIN; return 0;}
        if(s == "ERR_OUT_OF_SERVICE_UIN")  { e=ERR_OUT_OF_SERVICE_UIN; return 0;}
        if(s == "ERR_INACTIVE_UIN")  { e=ERR_INACTIVE_UIN; return 0;}
        if(s == "ERR_SYS_MAINTAIN")  { e=ERR_SYS_MAINTAIN; return 0;}

        return -1;
    }

    enum JceSpecUin
    {
        NOT_LOGIN_UIN_DEF = 2112,
    };
    inline string etos(const JceSpecUin & e)
    {
        switch(e)
        {
            case NOT_LOGIN_UIN_DEF: return "NOT_LOGIN_UIN_DEF";
            default: return "";
        }
    }
    inline int stoe(const string & s, JceSpecUin & e)
    {
        if(s == "NOT_LOGIN_UIN_DEF")  { e=NOT_LOGIN_UIN_DEF; return 0;}

        return -1;
    }

    struct HBasicInfo : public taf::JceStructBase
    {
    public:
        static string className()
        {
            return "videocomm.HBasicInfo";
        }
        static string MD5()
        {
            return "953da78890ab7992800316bde3c5cd94";
        }
        HBasicInfo()
        :ReqUin(0),Command(0),ServiceType(0),version(0),Result(0),CallerID(0),SeqId(0),SubCmd(0),BodyFlag(0)
        {
        }
        void resetDefautlt()
        {
            ReqUin = 0;
            Command = 0;
            ServiceType = 0;
            version = 0;
            Result = 0;
            CallerID = 0;
            SeqId = 0;
            SubCmd = 0;
            BodyFlag = 0;
        }
        template<typename WriterT>
        void writeTo(taf::JceOutputStream<WriterT>& _os) const
        {
            _os.write(ReqUin, 0);
            _os.write(Command, 1);
            _os.write(ServiceType, 2);
            _os.write(version, 3);
            _os.write(Result, 4);
            _os.write(CallerID, 5);
            _os.write(SeqId, 6);
            _os.write(SubCmd, 7);
            _os.write(BodyFlag, 8);
        }
        template<typename ReaderT>
        void readFrom(taf::JceInputStream<ReaderT>& _is)
        {
            resetDefautlt();
            _is.read(ReqUin, 0, true);
            _is.read(Command, 1, true);
            _is.read(ServiceType, 2, true);
            _is.read(version, 3, true);
            _is.read(Result, 4, true);
            _is.read(CallerID, 5, true);
            _is.read(SeqId, 6, true);
            _is.read(SubCmd, 7, false);
            _is.read(BodyFlag, 8, false);
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            taf::JceDisplayer _ds(_os, _level);
            _ds.display(ReqUin,"ReqUin");
            _ds.display(Command,"Command");
            _ds.display(ServiceType,"ServiceType");
            _ds.display(version,"version");
            _ds.display(Result,"Result");
            _ds.display(CallerID,"CallerID");
            _ds.display(SeqId,"SeqId");
            _ds.display(SubCmd,"SubCmd");
            _ds.display(BodyFlag,"BodyFlag");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            taf::JceDisplayer _ds(_os, _level);
            _ds.displaySimple(ReqUin, true);
            _ds.displaySimple(Command, true);
            _ds.displaySimple(ServiceType, true);
            _ds.displaySimple(version, true);
            _ds.displaySimple(Result, true);
            _ds.displaySimple(CallerID, true);
            _ds.displaySimple(SeqId, true);
            _ds.displaySimple(SubCmd, true);
            _ds.displaySimple(BodyFlag, false);
            return _os;
        }
    public:
        taf::Int64 ReqUin;
        taf::Short Command;
        taf::Char ServiceType;
        taf::Char version;
        taf::Int32 Result;
        taf::Int32 CallerID;
        taf::Int64 SeqId;
        taf::Int32 SubCmd;
        taf::Int32 BodyFlag;
    };
    inline bool operator==(const HBasicInfo&l, const HBasicInfo&r)
    {
        return l.ReqUin == r.ReqUin && l.Command == r.Command && l.ServiceType == r.ServiceType && l.version == r.version && l.Result == r.Result && l.CallerID == r.CallerID && l.SeqId == r.SeqId && l.SubCmd == r.SubCmd && l.BodyFlag == r.BodyFlag;
    }
    inline bool operator!=(const HBasicInfo&l, const HBasicInfo&r)
    {
        return !(l == r);
    }

    struct BucketConfig : public taf::JceStructBase
    {
    public:
        static string className()
        {
            return "videocomm.BucketConfig";
        }
        static string MD5()
        {
            return "1f47da24b69e655580a48d1f7cab279a";
        }
        BucketConfig()
        :bucketId(0),extra(""),strategyId("")
        {
        }
        void resetDefautlt()
        {
            bucketId = 0;
            extra = "";
            strategyId = "";
        }
        template<typename WriterT>
        void writeTo(taf::JceOutputStream<WriterT>& _os) const
        {
            _os.write(bucketId, 0);
            _os.write(extra, 1);
            _os.write(strategyId, 2);
        }
        template<typename ReaderT>
        void readFrom(taf::JceInputStream<ReaderT>& _is)
        {
            resetDefautlt();
            _is.read(bucketId, 0, true);
            _is.read(extra, 1, false);
            _is.read(strategyId, 2, false);
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            taf::JceDisplayer _ds(_os, _level);
            _ds.display(bucketId,"bucketId");
            _ds.display(extra,"extra");
            _ds.display(strategyId,"strategyId");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            taf::JceDisplayer _ds(_os, _level);
            _ds.displaySimple(bucketId, true);
            _ds.displaySimple(extra, true);
            _ds.displaySimple(strategyId, false);
            return _os;
        }
    public:
        taf::Int32 bucketId;
        std::string extra;
        std::string strategyId;
    };
    inline bool operator==(const BucketConfig&l, const BucketConfig&r)
    {
        return l.bucketId == r.bucketId && l.extra == r.extra && l.strategyId == r.strategyId;
    }
    inline bool operator!=(const BucketConfig&l, const BucketConfig&r)
    {
        return !(l == r);
    }

    struct ExtentData : public taf::JceStructBase
    {
    public:
        static string className()
        {
            return "videocomm.ExtentData";
        }
        static string MD5()
        {
            return "f116208492db907350968d04aea3bddf";
        }
        ExtentData()
        :checkFlag(0),flagByte(0),extent(""),blankId(0)
        {
        }
        void resetDefautlt()
        {
            checkFlag = 0;
            flagByte = 0;
            extent = "";
            blankId = 0;
        }
        template<typename WriterT>
        void writeTo(taf::JceOutputStream<WriterT>& _os) const
        {
            _os.write(checkFlag, 0);
            _os.write(flagByte, 1);
            _os.write(extent, 2);
            _os.write(blankId, 3);
            _os.write(bucketInfo, 4);
        }
        template<typename ReaderT>
        void readFrom(taf::JceInputStream<ReaderT>& _is)
        {
            resetDefautlt();
            _is.read(checkFlag, 0, false);
            _is.read(flagByte, 1, false);
            _is.read(extent, 2, false);
            _is.read(blankId, 3, false);
            _is.read(bucketInfo, 4, false);
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            taf::JceDisplayer _ds(_os, _level);
            _ds.display(checkFlag,"checkFlag");
            _ds.display(flagByte,"flagByte");
            _ds.display(extent,"extent");
            _ds.display(blankId,"blankId");
            _ds.display(bucketInfo,"bucketInfo");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            taf::JceDisplayer _ds(_os, _level);
            _ds.displaySimple(checkFlag, true);
            _ds.displaySimple(flagByte, true);
            _ds.displaySimple(extent, true);
            _ds.displaySimple(blankId, true);
            _ds.displaySimple(bucketInfo, false);
            return _os;
        }
    public:
        taf::Int32 checkFlag;
        taf::Char flagByte;
        std::string extent;
        taf::Int32 blankId;
        videocomm::BucketConfig bucketInfo;
    };
    inline bool operator==(const ExtentData&l, const ExtentData&r)
    {
        return l.checkFlag == r.checkFlag && l.flagByte == r.flagByte && l.extent == r.extent && l.blankId == r.blankId && l.bucketInfo == r.bucketInfo;
    }
    inline bool operator!=(const ExtentData&l, const ExtentData&r)
    {
        return !(l == r);
    }

    struct Coordinates : public taf::JceStructBase
    {
    public:
        static string className()
        {
            return "videocomm.Coordinates";
        }
        static string MD5()
        {
            return "71033ead3878bc0cfa11bb26706df957";
        }
        Coordinates()
        :type(0),latitude(0),longitude(0),accuracy(0)
        {
        }
        void resetDefautlt()
        {
            type = 0;
            latitude = 0;
            longitude = 0;
            accuracy = 0;
        }
        template<typename WriterT>
        void writeTo(taf::JceOutputStream<WriterT>& _os) const
        {
            _os.write(type, 0);
            _os.write(latitude, 1);
            _os.write(longitude, 2);
            _os.write(accuracy, 3);
        }
        template<typename ReaderT>
        void readFrom(taf::JceInputStream<ReaderT>& _is)
        {
            resetDefautlt();
            _is.read(type, 0, false);
            _is.read(latitude, 1, false);
            _is.read(longitude, 2, false);
            _is.read(accuracy, 3, false);
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            taf::JceDisplayer _ds(_os, _level);
            _ds.display(type,"type");
            _ds.display(latitude,"latitude");
            _ds.display(longitude,"longitude");
            _ds.display(accuracy,"accuracy");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            taf::JceDisplayer _ds(_os, _level);
            _ds.displaySimple(type, true);
            _ds.displaySimple(latitude, true);
            _ds.displaySimple(longitude, true);
            _ds.displaySimple(accuracy, false);
            return _os;
        }
    public:
        taf::Int32 type;
        taf::Float latitude;
        taf::Float longitude;
        taf::Double accuracy;
    };
    inline bool operator==(const Coordinates&l, const Coordinates&r)
    {
        return l.type == r.type && l.latitude == r.latitude && l.longitude == r.longitude && l.accuracy == r.accuracy;
    }
    inline bool operator!=(const Coordinates&l, const Coordinates&r)
    {
        return !(l == r);
    }

    struct HQua : public taf::JceStructBase
    {
    public:
        static string className()
        {
            return "videocomm.HQua";
        }
        static string MD5()
        {
            return "1268499e5bbe3c88cad754d432fa4e43";
        }
        HQua()
        :versionName(""),versionCode(""),screenWidth(0),screenHeight(0),platform(0),platformVersion(""),markerId(0),networkMode(0),densityDpi(0),channelId(""),imei(""),imsi(""),idfa(""),omgId(""),extent(""),oemPlatForm(0),strategyControl(""),isSupportDolby(0),sClientKey(""),sMac(""),serverId(""),deviceId(""),deviceModel(""),deviceType(0),mobileISP(0),areaMode(0)
        {
        }
        void resetDefautlt()
        {
            versionName = "";
            versionCode = "";
            screenWidth = 0;
            screenHeight = 0;
            platform = 0;
            platformVersion = "";
            markerId = 0;
            networkMode = 0;
            densityDpi = 0;
            channelId = "";
            imei = "";
            imsi = "";
            idfa = "";
            omgId = "";
            extent = "";
            oemPlatForm = 0;
            strategyControl = "";
            isSupportDolby = 0;
            sClientKey = "";
            sMac = "";
            serverId = "";
            deviceId = "";
            deviceModel = "";
            deviceType = 0;
            mobileISP = 0;
            areaMode = 0;
        }
        template<typename WriterT>
        void writeTo(taf::JceOutputStream<WriterT>& _os) const
        {
            _os.write(versionName, 0);
            _os.write(versionCode, 1);
            _os.write(screenWidth, 2);
            _os.write(screenHeight, 3);
            _os.write(platform, 4);
            _os.write(platformVersion, 5);
            _os.write(markerId, 6);
            _os.write(networkMode, 7);
            _os.write(densityDpi, 8);
            _os.write(channelId, 9);
            _os.write(imei, 10);
            _os.write(imsi, 11);
            _os.write(idfa, 12);
            _os.write(omgId, 13);
            _os.write(extent, 14);
            _os.write(extentData, 15);
            _os.write(oemPlatForm, 16);
            _os.write(strategyControl, 17);
            _os.write(isSupportDolby, 18);
            _os.write(sClientKey, 19);
            _os.write(sMac, 20);
            _os.write(serverId, 21);
            _os.write(coordinates, 22);
            _os.write(deviceId, 23);
            _os.write(deviceModel, 24);
            _os.write(deviceType, 25);
            _os.write(mobileISP, 26);
            _os.write(areaMode, 27);
        }
        template<typename ReaderT>
        void readFrom(taf::JceInputStream<ReaderT>& _is)
        {
            resetDefautlt();
            _is.read(versionName, 0, true);
            _is.read(versionCode, 1, true);
            _is.read(screenWidth, 2, false);
            _is.read(screenHeight, 3, false);
            _is.read(platform, 4, false);
            _is.read(platformVersion, 5, false);
            _is.read(markerId, 6, false);
            _is.read(networkMode, 7, false);
            _is.read(densityDpi, 8, false);
            _is.read(channelId, 9, false);
            _is.read(imei, 10, false);
            _is.read(imsi, 11, false);
            _is.read(idfa, 12, false);
            _is.read(omgId, 13, false);
            _is.read(extent, 14, false);
            _is.read(extentData, 15, false);
            _is.read(oemPlatForm, 16, false);
            _is.read(strategyControl, 17, false);
            _is.read(isSupportDolby, 18, false);
            _is.read(sClientKey, 19, false);
            _is.read(sMac, 20, false);
            _is.read(serverId, 21, false);
            _is.read(coordinates, 22, false);
            _is.read(deviceId, 23, false);
            _is.read(deviceModel, 24, false);
            _is.read(deviceType, 25, false);
            _is.read(mobileISP, 26, false);
            _is.read(areaMode, 27, false);
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            taf::JceDisplayer _ds(_os, _level);
            _ds.display(versionName,"versionName");
            _ds.display(versionCode,"versionCode");
            _ds.display(screenWidth,"screenWidth");
            _ds.display(screenHeight,"screenHeight");
            _ds.display(platform,"platform");
            _ds.display(platformVersion,"platformVersion");
            _ds.display(markerId,"markerId");
            _ds.display(networkMode,"networkMode");
            _ds.display(densityDpi,"densityDpi");
            _ds.display(channelId,"channelId");
            _ds.display(imei,"imei");
            _ds.display(imsi,"imsi");
            _ds.display(idfa,"idfa");
            _ds.display(omgId,"omgId");
            _ds.display(extent,"extent");
            _ds.display(extentData,"extentData");
            _ds.display(oemPlatForm,"oemPlatForm");
            _ds.display(strategyControl,"strategyControl");
            _ds.display(isSupportDolby,"isSupportDolby");
            _ds.display(sClientKey,"sClientKey");
            _ds.display(sMac,"sMac");
            _ds.display(serverId,"serverId");
            _ds.display(coordinates,"coordinates");
            _ds.display(deviceId,"deviceId");
            _ds.display(deviceModel,"deviceModel");
            _ds.display(deviceType,"deviceType");
            _ds.display(mobileISP,"mobileISP");
            _ds.display(areaMode,"areaMode");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            taf::JceDisplayer _ds(_os, _level);
            _ds.displaySimple(versionName, true);
            _ds.displaySimple(versionCode, true);
            _ds.displaySimple(screenWidth, true);
            _ds.displaySimple(screenHeight, true);
            _ds.displaySimple(platform, true);
            _ds.displaySimple(platformVersion, true);
            _ds.displaySimple(markerId, true);
            _ds.displaySimple(networkMode, true);
            _ds.displaySimple(densityDpi, true);
            _ds.displaySimple(channelId, true);
            _ds.displaySimple(imei, true);
            _ds.displaySimple(imsi, true);
            _ds.displaySimple(idfa, true);
            _ds.displaySimple(omgId, true);
            _ds.displaySimple(extent, true);
            _ds.displaySimple(extentData, true);
            _ds.displaySimple(oemPlatForm, true);
            _ds.displaySimple(strategyControl, true);
            _ds.displaySimple(isSupportDolby, true);
            _ds.displaySimple(sClientKey, true);
            _ds.displaySimple(sMac, true);
            _ds.displaySimple(serverId, true);
            _ds.displaySimple(coordinates, true);
            _ds.displaySimple(deviceId, true);
            _ds.displaySimple(deviceModel, true);
            _ds.displaySimple(deviceType, true);
            _ds.displaySimple(mobileISP, true);
            _ds.displaySimple(areaMode, false);
            return _os;
        }
    public:
        std::string versionName;
        std::string versionCode;
        taf::Int32 screenWidth;
        taf::Int32 screenHeight;
        taf::Int32 platform;
        std::string platformVersion;
        taf::Int32 markerId;
        taf::Int32 networkMode;
        taf::Int32 densityDpi;
        std::string channelId;
        std::string imei;
        std::string imsi;
        std::string idfa;
        std::string omgId;
        std::string extent;
        videocomm::ExtentData extentData;
        taf::Int32 oemPlatForm;
        std::string strategyControl;
        taf::Int32 isSupportDolby;
        std::string sClientKey;
        std::string sMac;
        std::string serverId;
        videocomm::Coordinates coordinates;
        std::string deviceId;
        std::string deviceModel;
        taf::Int32 deviceType;
        taf::Int32 mobileISP;
        taf::Int32 areaMode;
    };
    inline bool operator==(const HQua&l, const HQua&r)
    {
        return l.versionName == r.versionName && l.versionCode == r.versionCode && l.screenWidth == r.screenWidth && l.screenHeight == r.screenHeight && l.platform == r.platform && l.platformVersion == r.platformVersion && l.markerId == r.markerId && l.networkMode == r.networkMode && l.densityDpi == r.densityDpi && l.channelId == r.channelId && l.imei == r.imei && l.imsi == r.imsi && l.idfa == r.idfa && l.omgId == r.omgId && l.extent == r.extent && l.extentData == r.extentData && l.oemPlatForm == r.oemPlatForm && l.strategyControl == r.strategyControl && l.isSupportDolby == r.isSupportDolby && l.sClientKey == r.sClientKey && l.sMac == r.sMac && l.serverId == r.serverId && l.coordinates == r.coordinates && l.deviceId == r.deviceId && l.deviceModel == r.deviceModel && l.deviceType == r.deviceType && l.mobileISP == r.mobileISP && l.areaMode == r.areaMode;
    }
    inline bool operator!=(const HQua&l, const HQua&r)
    {
        return !(l == r);
    }

    struct LogReport : public taf::JceStructBase
    {
    public:
        static string className()
        {
            return "videocomm.LogReport";
        }
        static string MD5()
        {
            return "b515190adf6c5dd86ad7fc2b8c930806";
        }
        LogReport()
        :pageId(""),refPageId(""),pageStep(0),callType(""),isAuto(0),vid(""),pid(""),sFromInfo(""),channelId(""),mid(""),extent("")
        {
        }
        void resetDefautlt()
        {
            pageId = "";
            refPageId = "";
            pageStep = 0;
            callType = "";
            isAuto = 0;
            vid = "";
            pid = "";
            sFromInfo = "";
            channelId = "";
            mid = "";
            extent = "";
        }
        template<typename WriterT>
        void writeTo(taf::JceOutputStream<WriterT>& _os) const
        {
            _os.write(pageId, 0);
            _os.write(refPageId, 1);
            _os.write(pageStep, 2);
            _os.write(callType, 3);
            _os.write(isAuto, 4);
            _os.write(vid, 5);
            _os.write(pid, 6);
            _os.write(sFromInfo, 7);
            _os.write(channelId, 8);
            _os.write(mid, 9);
            _os.write(extent, 10);
        }
        template<typename ReaderT>
        void readFrom(taf::JceInputStream<ReaderT>& _is)
        {
            resetDefautlt();
            _is.read(pageId, 0, false);
            _is.read(refPageId, 1, false);
            _is.read(pageStep, 2, false);
            _is.read(callType, 3, false);
            _is.read(isAuto, 4, false);
            _is.read(vid, 5, false);
            _is.read(pid, 6, false);
            _is.read(sFromInfo, 7, false);
            _is.read(channelId, 8, false);
            _is.read(mid, 9, false);
            _is.read(extent, 10, false);
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            taf::JceDisplayer _ds(_os, _level);
            _ds.display(pageId,"pageId");
            _ds.display(refPageId,"refPageId");
            _ds.display(pageStep,"pageStep");
            _ds.display(callType,"callType");
            _ds.display(isAuto,"isAuto");
            _ds.display(vid,"vid");
            _ds.display(pid,"pid");
            _ds.display(sFromInfo,"sFromInfo");
            _ds.display(channelId,"channelId");
            _ds.display(mid,"mid");
            _ds.display(extent,"extent");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            taf::JceDisplayer _ds(_os, _level);
            _ds.displaySimple(pageId, true);
            _ds.displaySimple(refPageId, true);
            _ds.displaySimple(pageStep, true);
            _ds.displaySimple(callType, true);
            _ds.displaySimple(isAuto, true);
            _ds.displaySimple(vid, true);
            _ds.displaySimple(pid, true);
            _ds.displaySimple(sFromInfo, true);
            _ds.displaySimple(channelId, true);
            _ds.displaySimple(mid, true);
            _ds.displaySimple(extent, false);
            return _os;
        }
    public:
        std::string pageId;
        std::string refPageId;
        taf::Int32 pageStep;
        std::string callType;
        taf::Int32 isAuto;
        std::string vid;
        std::string pid;
        std::string sFromInfo;
        std::string channelId;
        std::string mid;
        std::string extent;
    };
    inline bool operator==(const LogReport&l, const LogReport&r)
    {
        return l.pageId == r.pageId && l.refPageId == r.refPageId && l.pageStep == r.pageStep && l.callType == r.callType && l.isAuto == r.isAuto && l.vid == r.vid && l.pid == r.pid && l.sFromInfo == r.sFromInfo && l.channelId == r.channelId && l.mid == r.mid && l.extent == r.extent;
    }
    inline bool operator!=(const LogReport&l, const LogReport&r)
    {
        return !(l == r);
    }

    struct ExtentAccount : public taf::JceStructBase
    {
    public:
        static string className()
        {
            return "videocomm.ExtentAccount";
        }
        static string MD5()
        {
            return "26159cf77dcb9fe1c64b57dae580ccae";
        }
        ExtentAccount()
        :type(0),accountId("")
        {
        }
        void resetDefautlt()
        {
            type = 0;
            accountId = "";
        }
        template<typename WriterT>
        void writeTo(taf::JceOutputStream<WriterT>& _os) const
        {
            _os.write(type, 0);
            _os.write(accountId, 1);
        }
        template<typename ReaderT>
        void readFrom(taf::JceInputStream<ReaderT>& _is)
        {
            resetDefautlt();
            _is.read(type, 0, true);
            _is.read(accountId, 1, true);
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            taf::JceDisplayer _ds(_os, _level);
            _ds.display(type,"type");
            _ds.display(accountId,"accountId");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            taf::JceDisplayer _ds(_os, _level);
            _ds.displaySimple(type, true);
            _ds.displaySimple(accountId, false);
            return _os;
        }
    public:
        taf::Int32 type;
        std::string accountId;
    };
    inline bool operator==(const ExtentAccount&l, const ExtentAccount&r)
    {
        return l.type == r.type && l.accountId == r.accountId;
    }
    inline bool operator!=(const ExtentAccount&l, const ExtentAccount&r)
    {
        return !(l == r);
    }

    struct HAccessInfo : public taf::JceStructBase
    {
    public:
        static string className()
        {
            return "videocomm.HAccessInfo";
        }
        static string MD5()
        {
            return "f3953fe2b3669c8966f60bc6e6440bd6";
        }
        HAccessInfo()
        :ProxyIP(0),ServerIP(0),ClientIP(0),ClientPort(0),ServiceTime(0),ServiceName(""),RtxName(""),FileName(""),FuncName(""),Line(0),CgiProcId(""),FromInfo(""),AccIP(0),AccPort(0),AccId(0),ClientID(0),Guid(""),Flag(0),Seq(0),AreaCodeInfo(""),HttpCookie("")
        {
        }
        void resetDefautlt()
        {
            ProxyIP = 0;
            ServerIP = 0;
            ClientIP = 0;
            ClientPort = 0;
            ServiceTime = 0;
            ServiceName = "";
            RtxName = "";
            FileName = "";
            FuncName = "";
            Line = 0;
            CgiProcId = "";
            FromInfo = "";
            AccIP = 0;
            AccPort = 0;
            AccId = 0;
            ClientID = 0;
            Guid = "";
            Flag = 0;
            Seq = 0;
            AreaCodeInfo = "";
            HttpCookie = "";
        }
        template<typename WriterT>
        void writeTo(taf::JceOutputStream<WriterT>& _os) const
        {
            _os.write(ProxyIP, 0);
            _os.write(ServerIP, 1);
            _os.write(ClientIP, 2);
            _os.write(ClientPort, 3);
            _os.write(ServiceTime, 4);
            _os.write(ServiceName, 5);
            _os.write(RtxName, 6);
            _os.write(FileName, 7);
            _os.write(FuncName, 8);
            _os.write(Line, 9);
            _os.write(CgiProcId, 10);
            _os.write(FromInfo, 11);
            _os.write(AccIP, 12);
            _os.write(AccPort, 13);
            _os.write(AccId, 14);
            _os.write(ClientID, 15);
            _os.write(QUAInfo, 16);
            _os.write(Guid, 17);
            _os.write(BossReport, 18);
            _os.write(Flag, 19);
            _os.write(Seq, 20);
            _os.write(extentAccountList, 21);
            _os.write(AreaCodeInfo, 22);
            _os.write(HttpCookie, 23);
        }
        template<typename ReaderT>
        void readFrom(taf::JceInputStream<ReaderT>& _is)
        {
            resetDefautlt();
            _is.read(ProxyIP, 0, false);
            _is.read(ServerIP, 1, false);
            _is.read(ClientIP, 2, false);
            _is.read(ClientPort, 3, false);
            _is.read(ServiceTime, 4, false);
            _is.read(ServiceName, 5, false);
            _is.read(RtxName, 6, false);
            _is.read(FileName, 7, false);
            _is.read(FuncName, 8, false);
            _is.read(Line, 9, false);
            _is.read(CgiProcId, 10, false);
            _is.read(FromInfo, 11, false);
            _is.read(AccIP, 12, false);
            _is.read(AccPort, 13, false);
            _is.read(AccId, 14, false);
            _is.read(ClientID, 15, false);
            _is.read(QUAInfo, 16, false);
            _is.read(Guid, 17, false);
            _is.read(BossReport, 18, false);
            _is.read(Flag, 19, false);
            _is.read(Seq, 20, false);
            _is.read(extentAccountList, 21, false);
            _is.read(AreaCodeInfo, 22, false);
            _is.read(HttpCookie, 23, false);
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            taf::JceDisplayer _ds(_os, _level);
            _ds.display(ProxyIP,"ProxyIP");
            _ds.display(ServerIP,"ServerIP");
            _ds.display(ClientIP,"ClientIP");
            _ds.display(ClientPort,"ClientPort");
            _ds.display(ServiceTime,"ServiceTime");
            _ds.display(ServiceName,"ServiceName");
            _ds.display(RtxName,"RtxName");
            _ds.display(FileName,"FileName");
            _ds.display(FuncName,"FuncName");
            _ds.display(Line,"Line");
            _ds.display(CgiProcId,"CgiProcId");
            _ds.display(FromInfo,"FromInfo");
            _ds.display(AccIP,"AccIP");
            _ds.display(AccPort,"AccPort");
            _ds.display(AccId,"AccId");
            _ds.display(ClientID,"ClientID");
            _ds.display(QUAInfo,"QUAInfo");
            _ds.display(Guid,"Guid");
            _ds.display(BossReport,"BossReport");
            _ds.display(Flag,"Flag");
            _ds.display(Seq,"Seq");
            _ds.display(extentAccountList,"extentAccountList");
            _ds.display(AreaCodeInfo,"AreaCodeInfo");
            _ds.display(HttpCookie,"HttpCookie");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            taf::JceDisplayer _ds(_os, _level);
            _ds.displaySimple(ProxyIP, true);
            _ds.displaySimple(ServerIP, true);
            _ds.displaySimple(ClientIP, true);
            _ds.displaySimple(ClientPort, true);
            _ds.displaySimple(ServiceTime, true);
            _ds.displaySimple(ServiceName, true);
            _ds.displaySimple(RtxName, true);
            _ds.displaySimple(FileName, true);
            _ds.displaySimple(FuncName, true);
            _ds.displaySimple(Line, true);
            _ds.displaySimple(CgiProcId, true);
            _ds.displaySimple(FromInfo, true);
            _ds.displaySimple(AccIP, true);
            _ds.displaySimple(AccPort, true);
            _ds.displaySimple(AccId, true);
            _ds.displaySimple(ClientID, true);
            _ds.displaySimple(QUAInfo, true);
            _ds.displaySimple(Guid, true);
            _ds.displaySimple(BossReport, true);
            _ds.displaySimple(Flag, true);
            _ds.displaySimple(Seq, true);
            _ds.displaySimple(extentAccountList, true);
            _ds.displaySimple(AreaCodeInfo, true);
            _ds.displaySimple(HttpCookie, false);
            return _os;
        }
    public:
        taf::Int32 ProxyIP;
        taf::Int32 ServerIP;
        taf::Int64 ClientIP;
        taf::Short ClientPort;
        taf::Int32 ServiceTime;
        std::string ServiceName;
        std::string RtxName;
        std::string FileName;
        std::string FuncName;
        taf::Int32 Line;
        std::string CgiProcId;
        std::string FromInfo;
        taf::Int64 AccIP;
        taf::Int32 AccPort;
        taf::Int64 AccId;
        taf::Int64 ClientID;
        videocomm::HQua QUAInfo;
        std::string Guid;
        videocomm::LogReport BossReport;
        taf::Int32 Flag;
        taf::Int64 Seq;
        vector<videocomm::ExtentAccount> extentAccountList;
        std::string AreaCodeInfo;
        std::string HttpCookie;
    };
    inline bool operator==(const HAccessInfo&l, const HAccessInfo&r)
    {
        return l.ProxyIP == r.ProxyIP && l.ServerIP == r.ServerIP && l.ClientIP == r.ClientIP && l.ClientPort == r.ClientPort && l.ServiceTime == r.ServiceTime && l.ServiceName == r.ServiceName && l.RtxName == r.RtxName && l.FileName == r.FileName && l.FuncName == r.FuncName && l.Line == r.Line && l.CgiProcId == r.CgiProcId && l.FromInfo == r.FromInfo && l.AccIP == r.AccIP && l.AccPort == r.AccPort && l.AccId == r.AccId && l.ClientID == r.ClientID && l.QUAInfo == r.QUAInfo && l.Guid == r.Guid && l.BossReport == r.BossReport && l.Flag == r.Flag && l.Seq == r.Seq && l.extentAccountList == r.extentAccountList && l.AreaCodeInfo == r.AreaCodeInfo && l.HttpCookie == r.HttpCookie;
    }
    inline bool operator!=(const HAccessInfo&l, const HAccessInfo&r)
    {
        return !(l == r);
    }

    struct HLoginToken : public taf::JceStructBase
    {
    public:
        static string className()
        {
            return "videocomm.HLoginToken";
        }
        static string MD5()
        {
            return "446ebdd8da79ec25637c7baf5aad0c65";
        }
        HLoginToken()
        :TokenAppID(""),TokenKeyType(0),TokenValue(""),TokenUin(0),TokenID(""),Result(0),bMainLogin(true)
        {
        }
        void resetDefautlt()
        {
            TokenAppID = "";
            TokenKeyType = 0;
            TokenValue = "";
            TokenUin = 0;
            TokenID = "";
            Result = 0;
            bMainLogin = true;
        }
        template<typename WriterT>
        void writeTo(taf::JceOutputStream<WriterT>& _os) const
        {
            _os.write(TokenAppID, 1);
            _os.write(TokenKeyType, 2);
            _os.write(TokenValue, 3);
            _os.write(TokenUin, 4);
            _os.write(TokenID, 5);
            _os.write(Result, 6);
            _os.write(bMainLogin, 7);
        }
        template<typename ReaderT>
        void readFrom(taf::JceInputStream<ReaderT>& _is)
        {
            resetDefautlt();
            _is.read(TokenAppID, 1, true);
            _is.read(TokenKeyType, 2, true);
            _is.read(TokenValue, 3, true);
            _is.read(TokenUin, 4, false);
            _is.read(TokenID, 5, false);
            _is.read(Result, 6, false);
            _is.read(bMainLogin, 7, false);
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            taf::JceDisplayer _ds(_os, _level);
            _ds.display(TokenAppID,"TokenAppID");
            _ds.display(TokenKeyType,"TokenKeyType");
            _ds.display(TokenValue,"TokenValue");
            _ds.display(TokenUin,"TokenUin");
            _ds.display(TokenID,"TokenID");
            _ds.display(Result,"Result");
            _ds.display(bMainLogin,"bMainLogin");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            taf::JceDisplayer _ds(_os, _level);
            _ds.displaySimple(TokenAppID, true);
            _ds.displaySimple(TokenKeyType, true);
            _ds.displaySimple(TokenValue, true);
            _ds.displaySimple(TokenUin, true);
            _ds.displaySimple(TokenID, true);
            _ds.displaySimple(Result, true);
            _ds.displaySimple(bMainLogin, false);
            return _os;
        }
    public:
        std::string TokenAppID;
        taf::Char TokenKeyType;
        std::string TokenValue;
        taf::Int64 TokenUin;
        std::string TokenID;
        taf::UInt32 Result;
        taf::Bool bMainLogin;
    };
    inline bool operator==(const HLoginToken&l, const HLoginToken&r)
    {
        return l.TokenAppID == r.TokenAppID && l.TokenKeyType == r.TokenKeyType && l.TokenValue == r.TokenValue && l.TokenUin == r.TokenUin && l.TokenID == r.TokenID && l.Result == r.Result && l.bMainLogin == r.bMainLogin;
    }
    inline bool operator!=(const HLoginToken&l, const HLoginToken&r)
    {
        return !(l == r);
    }

    struct HttpRequest : public taf::JceStructBase
    {
    public:
        static string className()
        {
            return "videocomm.HttpRequest";
        }
        static string MD5()
        {
            return "fb7b08348c523140e62ca2d82a0c2c6b";
        }
        HttpRequest()
        :ClientIP(0),RequestType(0),Url(""),Accept(""),UserAgent(""),Host(""),Referer(""),PostData("")
        {
        }
        void resetDefautlt()
        {
            ClientIP = 0;
            RequestType = 0;
            Url = "";
            Accept = "";
            UserAgent = "";
            Host = "";
            Referer = "";
            PostData = "";
        }
        template<typename WriterT>
        void writeTo(taf::JceOutputStream<WriterT>& _os) const
        {
            _os.write(ClientIP, 0);
            _os.write(RequestType, 1);
            _os.write(Url, 2);
            _os.write(Accept, 3);
            _os.write(UserAgent, 4);
            _os.write(Host, 5);
            _os.write(Referer, 6);
            _os.write(PostData, 7);
            _os.write(Cookies, 8);
            _os.write(Queries, 9);
            _os.write(MoreHeaders, 10);
        }
        template<typename ReaderT>
        void readFrom(taf::JceInputStream<ReaderT>& _is)
        {
            resetDefautlt();
            _is.read(ClientIP, 0, false);
            _is.read(RequestType, 1, false);
            _is.read(Url, 2, false);
            _is.read(Accept, 3, false);
            _is.read(UserAgent, 4, false);
            _is.read(Host, 5, false);
            _is.read(Referer, 6, false);
            _is.read(PostData, 7, false);
            _is.read(Cookies, 8, false);
            _is.read(Queries, 9, false);
            _is.read(MoreHeaders, 10, false);
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            taf::JceDisplayer _ds(_os, _level);
            _ds.display(ClientIP,"ClientIP");
            _ds.display(RequestType,"RequestType");
            _ds.display(Url,"Url");
            _ds.display(Accept,"Accept");
            _ds.display(UserAgent,"UserAgent");
            _ds.display(Host,"Host");
            _ds.display(Referer,"Referer");
            _ds.display(PostData,"PostData");
            _ds.display(Cookies,"Cookies");
            _ds.display(Queries,"Queries");
            _ds.display(MoreHeaders,"MoreHeaders");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            taf::JceDisplayer _ds(_os, _level);
            _ds.displaySimple(ClientIP, true);
            _ds.displaySimple(RequestType, true);
            _ds.displaySimple(Url, true);
            _ds.displaySimple(Accept, true);
            _ds.displaySimple(UserAgent, true);
            _ds.displaySimple(Host, true);
            _ds.displaySimple(Referer, true);
            _ds.displaySimple(PostData, true);
            _ds.displaySimple(Cookies, true);
            _ds.displaySimple(Queries, true);
            _ds.displaySimple(MoreHeaders, false);
            return _os;
        }
    public:
        taf::Int64 ClientIP;
        taf::Int32 RequestType;
        std::string Url;
        std::string Accept;
        std::string UserAgent;
        std::string Host;
        std::string Referer;
        std::string PostData;
        map<std::string, std::string> Cookies;
        map<std::string, std::string> Queries;
        map<std::string, std::string> MoreHeaders;
    };
    inline bool operator==(const HttpRequest&l, const HttpRequest&r)
    {
        return l.ClientIP == r.ClientIP && l.RequestType == r.RequestType && l.Url == r.Url && l.Accept == r.Accept && l.UserAgent == r.UserAgent && l.Host == r.Host && l.Referer == r.Referer && l.PostData == r.PostData && l.Cookies == r.Cookies && l.Queries == r.Queries && l.MoreHeaders == r.MoreHeaders;
    }
    inline bool operator!=(const HttpRequest&l, const HttpRequest&r)
    {
        return !(l == r);
    }

    struct HttpKV : public taf::JceStructBase
    {
    public:
        static string className()
        {
            return "videocomm.HttpKV";
        }
        static string MD5()
        {
            return "325d87d477a8cf7a6468ed6bb39da964";
        }
        HttpKV()
        :httpKey(""),httpValue("")
        {
        }
        void resetDefautlt()
        {
            httpKey = "";
            httpValue = "";
        }
        template<typename WriterT>
        void writeTo(taf::JceOutputStream<WriterT>& _os) const
        {
            _os.write(httpKey, 0);
            _os.write(httpValue, 1);
        }
        template<typename ReaderT>
        void readFrom(taf::JceInputStream<ReaderT>& _is)
        {
            resetDefautlt();
            _is.read(httpKey, 0, false);
            _is.read(httpValue, 1, false);
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            taf::JceDisplayer _ds(_os, _level);
            _ds.display(httpKey,"httpKey");
            _ds.display(httpValue,"httpValue");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            taf::JceDisplayer _ds(_os, _level);
            _ds.displaySimple(httpKey, true);
            _ds.displaySimple(httpValue, false);
            return _os;
        }
    public:
        std::string httpKey;
        std::string httpValue;
    };
    inline bool operator==(const HttpKV&l, const HttpKV&r)
    {
        return l.httpKey == r.httpKey && l.httpValue == r.httpValue;
    }
    inline bool operator!=(const HttpKV&l, const HttpKV&r)
    {
        return !(l == r);
    }

    struct HttpResponse : public taf::JceStructBase
    {
    public:
        static string className()
        {
            return "videocomm.HttpResponse";
        }
        static string MD5()
        {
            return "47155a1d66683ab0bba522483ea3e317";
        }
        HttpResponse()
        :ReturnBody("")
        {
        }
        void resetDefautlt()
        {
            ReturnBody = "";
        }
        template<typename WriterT>
        void writeTo(taf::JceOutputStream<WriterT>& _os) const
        {
            _os.write(HttpActions, 0);
            _os.write(ReturnBody, 1);
        }
        template<typename ReaderT>
        void readFrom(taf::JceInputStream<ReaderT>& _is)
        {
            resetDefautlt();
            _is.read(HttpActions, 0, false);
            _is.read(ReturnBody, 1, false);
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            taf::JceDisplayer _ds(_os, _level);
            _ds.display(HttpActions,"HttpActions");
            _ds.display(ReturnBody,"ReturnBody");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            taf::JceDisplayer _ds(_os, _level);
            _ds.displaySimple(HttpActions, true);
            _ds.displaySimple(ReturnBody, false);
            return _os;
        }
    public:
        vector<videocomm::HttpKV> HttpActions;
        std::string ReturnBody;
    };
    inline bool operator==(const HttpResponse&l, const HttpResponse&r)
    {
        return l.HttpActions == r.HttpActions && l.ReturnBody == r.ReturnBody;
    }
    inline bool operator!=(const HttpResponse&l, const HttpResponse&r)
    {
        return !(l == r);
    }

    struct HttpData : public taf::JceStructBase
    {
    public:
        static string className()
        {
            return "videocomm.HttpData";
        }
        static string MD5()
        {
            return "2e29599aa8f89c73da0e13ba25d9be34";
        }
        HttpData()
        {
        }
        void resetDefautlt()
        {
        }
        template<typename WriterT>
        void writeTo(taf::JceOutputStream<WriterT>& _os) const
        {
            _os.write(Request, 0);
            _os.write(Response, 1);
        }
        template<typename ReaderT>
        void readFrom(taf::JceInputStream<ReaderT>& _is)
        {
            resetDefautlt();
            _is.read(Request, 0, false);
            _is.read(Response, 1, false);
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            taf::JceDisplayer _ds(_os, _level);
            _ds.display(Request,"Request");
            _ds.display(Response,"Response");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            taf::JceDisplayer _ds(_os, _level);
            _ds.displaySimple(Request, true);
            _ds.displaySimple(Response, false);
            return _os;
        }
    public:
        videocomm::HttpRequest Request;
        videocomm::HttpResponse Response;
    };
    inline bool operator==(const HttpData&l, const HttpData&r)
    {
        return l.Request == r.Request && l.Response == r.Response;
    }
    inline bool operator!=(const HttpData&l, const HttpData&r)
    {
        return !(l == r);
    }

    struct HAccCmdBody : public taf::JceStructBase
    {
    public:
        static string className()
        {
            return "videocomm.HAccCmdBody";
        }
        static string MD5()
        {
            return "1a8c01ac30cdc30679a5300e611dc815";
        }
        HAccCmdBody()
        :AccCmd(0),AccSubCmd(0),AccBody("")
        {
        }
        void resetDefautlt()
        {
            AccCmd = 0;
            AccSubCmd = 0;
            AccBody = "";
        }
        template<typename WriterT>
        void writeTo(taf::JceOutputStream<WriterT>& _os) const
        {
            _os.write(AccCmd, 1);
            _os.write(AccSubCmd, 2);
            _os.write(AccBody, 3);
        }
        template<typename ReaderT>
        void readFrom(taf::JceInputStream<ReaderT>& _is)
        {
            resetDefautlt();
            _is.read(AccCmd, 1, false);
            _is.read(AccSubCmd, 2, false);
            _is.read(AccBody, 3, false);
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            taf::JceDisplayer _ds(_os, _level);
            _ds.display(AccCmd,"AccCmd");
            _ds.display(AccSubCmd,"AccSubCmd");
            _ds.display(AccBody,"AccBody");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            taf::JceDisplayer _ds(_os, _level);
            _ds.displaySimple(AccCmd, true);
            _ds.displaySimple(AccSubCmd, true);
            _ds.displaySimple(AccBody, false);
            return _os;
        }
    public:
        taf::Short AccCmd;
        taf::Int32 AccSubCmd;
        std::string AccBody;
    };
    inline bool operator==(const HAccCmdBody&l, const HAccCmdBody&r)
    {
        return l.AccCmd == r.AccCmd && l.AccSubCmd == r.AccSubCmd && l.AccBody == r.AccBody;
    }
    inline bool operator!=(const HAccCmdBody&l, const HAccCmdBody&r)
    {
        return !(l == r);
    }

    struct BusinessHead : public taf::JceStructBase
    {
    public:
        static string className()
        {
            return "videocomm.BusinessHead";
        }
        static string MD5()
        {
            return "26159cf77dcb9fe1c64b57dae580ccae";
        }
        BusinessHead()
        :type(0),body("")
        {
        }
        void resetDefautlt()
        {
            type = 0;
            body = "";
        }
        template<typename WriterT>
        void writeTo(taf::JceOutputStream<WriterT>& _os) const
        {
            _os.write(type, 0);
            _os.write(body, 1);
        }
        template<typename ReaderT>
        void readFrom(taf::JceInputStream<ReaderT>& _is)
        {
            resetDefautlt();
            _is.read(type, 0, true);
            _is.read(body, 1, true);
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            taf::JceDisplayer _ds(_os, _level);
            _ds.display(type,"type");
            _ds.display(body,"body");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            taf::JceDisplayer _ds(_os, _level);
            _ds.displaySimple(type, true);
            _ds.displaySimple(body, false);
            return _os;
        }
    public:
        taf::Int32 type;
        std::string body;
    };
    inline bool operator==(const BusinessHead&l, const BusinessHead&r)
    {
        return l.type == r.type && l.body == r.body;
    }
    inline bool operator!=(const BusinessHead&l, const BusinessHead&r)
    {
        return !(l == r);
    }

    struct VideoCommHeader : public taf::JceStructBase
    {
    public:
        static string className()
        {
            return "videocomm.VideoCommHeader";
        }
        static string MD5()
        {
            return "956ca73146485d48903c3566af2e82de";
        }
        VideoCommHeader()
        :body("")
        {
        }
        void resetDefautlt()
        {
            body = "";
        }
        template<typename WriterT>
        void writeTo(taf::JceOutputStream<WriterT>& _os) const
        {
            _os.write(BasicInfo, 0);
            _os.write(AccessInfo, 1);
            _os.write(LoginTokens, 2);
            _os.write(body, 3);
            _os.write(AccCmdBody, 4);
            _os.write(HttpBody, 5);
            _os.write(businessHead, 6);
        }
        template<typename ReaderT>
        void readFrom(taf::JceInputStream<ReaderT>& _is)
        {
            resetDefautlt();
            _is.read(BasicInfo, 0, true);
            _is.read(AccessInfo, 1, true);
            _is.read(LoginTokens, 2, false);
            _is.read(body, 3, false);
            _is.read(AccCmdBody, 4, false);
            _is.read(HttpBody, 5, false);
            _is.read(businessHead, 6, false);
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            taf::JceDisplayer _ds(_os, _level);
            _ds.display(BasicInfo,"BasicInfo");
            _ds.display(AccessInfo,"AccessInfo");
            _ds.display(LoginTokens,"LoginTokens");
            _ds.display(body,"body");
            _ds.display(AccCmdBody,"AccCmdBody");
            _ds.display(HttpBody,"HttpBody");
            _ds.display(businessHead,"businessHead");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            taf::JceDisplayer _ds(_os, _level);
            _ds.displaySimple(BasicInfo, true);
            _ds.displaySimple(AccessInfo, true);
            _ds.displaySimple(LoginTokens, true);
            _ds.displaySimple(body, true);
            _ds.displaySimple(AccCmdBody, true);
            _ds.displaySimple(HttpBody, true);
            _ds.displaySimple(businessHead, false);
            return _os;
        }
    public:
        videocomm::HBasicInfo BasicInfo;
        videocomm::HAccessInfo AccessInfo;
        vector<videocomm::HLoginToken> LoginTokens;
        std::string body;
        vector<videocomm::HAccCmdBody> AccCmdBody;
        videocomm::HttpData HttpBody;
        videocomm::BusinessHead businessHead;
    };
    inline bool operator==(const VideoCommHeader&l, const VideoCommHeader&r)
    {
        return l.BasicInfo == r.BasicInfo && l.AccessInfo == r.AccessInfo && l.LoginTokens == r.LoginTokens && l.body == r.body && l.AccCmdBody == r.AccCmdBody && l.HttpBody == r.HttpBody && l.businessHead == r.businessHead;
    }
    inline bool operator!=(const VideoCommHeader&l, const VideoCommHeader&r)
    {
        return !(l == r);
    }


}

#define videocomm_HBasicInfo_JCE_COPY_STRUCT_HELPER   \
        jce_copy_struct(a.ReqUin,b.ReqUin);jce_copy_struct(a.Command,b.Command);jce_copy_struct(a.ServiceType,b.ServiceType);jce_copy_struct(a.version,b.version);jce_copy_struct(a.Result,b.Result);jce_copy_struct(a.CallerID,b.CallerID);jce_copy_struct(a.SeqId,b.SeqId);jce_copy_struct(a.SubCmd,b.SubCmd);jce_copy_struct(a.BodyFlag,b.BodyFlag);

#define videocomm_BucketConfig_JCE_COPY_STRUCT_HELPER   \
        jce_copy_struct(a.bucketId,b.bucketId);jce_copy_struct(a.extra,b.extra);jce_copy_struct(a.strategyId,b.strategyId);

#define videocomm_ExtentData_JCE_COPY_STRUCT_HELPER   \
        jce_copy_struct(a.checkFlag,b.checkFlag);jce_copy_struct(a.flagByte,b.flagByte);jce_copy_struct(a.extent,b.extent);jce_copy_struct(a.blankId,b.blankId);jce_copy_struct(a.bucketInfo,b.bucketInfo);

#define videocomm_Coordinates_JCE_COPY_STRUCT_HELPER   \
        jce_copy_struct(a.type,b.type);jce_copy_struct(a.latitude,b.latitude);jce_copy_struct(a.longitude,b.longitude);jce_copy_struct(a.accuracy,b.accuracy);

#define videocomm_HQua_JCE_COPY_STRUCT_HELPER   \
        jce_copy_struct(a.versionName,b.versionName);jce_copy_struct(a.versionCode,b.versionCode);jce_copy_struct(a.screenWidth,b.screenWidth);jce_copy_struct(a.screenHeight,b.screenHeight);jce_copy_struct(a.platform,b.platform);jce_copy_struct(a.platformVersion,b.platformVersion);jce_copy_struct(a.markerId,b.markerId);jce_copy_struct(a.networkMode,b.networkMode);jce_copy_struct(a.densityDpi,b.densityDpi);jce_copy_struct(a.channelId,b.channelId);jce_copy_struct(a.imei,b.imei);jce_copy_struct(a.imsi,b.imsi);jce_copy_struct(a.idfa,b.idfa);jce_copy_struct(a.omgId,b.omgId);jce_copy_struct(a.extent,b.extent);jce_copy_struct(a.extentData,b.extentData);jce_copy_struct(a.oemPlatForm,b.oemPlatForm);jce_copy_struct(a.strategyControl,b.strategyControl);jce_copy_struct(a.isSupportDolby,b.isSupportDolby);jce_copy_struct(a.sClientKey,b.sClientKey);jce_copy_struct(a.sMac,b.sMac);jce_copy_struct(a.serverId,b.serverId);jce_copy_struct(a.coordinates,b.coordinates);jce_copy_struct(a.deviceId,b.deviceId);jce_copy_struct(a.deviceModel,b.deviceModel);jce_copy_struct(a.deviceType,b.deviceType);jce_copy_struct(a.mobileISP,b.mobileISP);jce_copy_struct(a.areaMode,b.areaMode);

#define videocomm_LogReport_JCE_COPY_STRUCT_HELPER   \
        jce_copy_struct(a.pageId,b.pageId);jce_copy_struct(a.refPageId,b.refPageId);jce_copy_struct(a.pageStep,b.pageStep);jce_copy_struct(a.callType,b.callType);jce_copy_struct(a.isAuto,b.isAuto);jce_copy_struct(a.vid,b.vid);jce_copy_struct(a.pid,b.pid);jce_copy_struct(a.sFromInfo,b.sFromInfo);jce_copy_struct(a.channelId,b.channelId);jce_copy_struct(a.mid,b.mid);jce_copy_struct(a.extent,b.extent);

#define videocomm_ExtentAccount_JCE_COPY_STRUCT_HELPER   \
        jce_copy_struct(a.type,b.type);jce_copy_struct(a.accountId,b.accountId);

#define videocomm_HAccessInfo_JCE_COPY_STRUCT_HELPER   \
        jce_copy_struct(a.ProxyIP,b.ProxyIP);jce_copy_struct(a.ServerIP,b.ServerIP);jce_copy_struct(a.ClientIP,b.ClientIP);jce_copy_struct(a.ClientPort,b.ClientPort);jce_copy_struct(a.ServiceTime,b.ServiceTime);jce_copy_struct(a.ServiceName,b.ServiceName);jce_copy_struct(a.RtxName,b.RtxName);jce_copy_struct(a.FileName,b.FileName);jce_copy_struct(a.FuncName,b.FuncName);jce_copy_struct(a.Line,b.Line);jce_copy_struct(a.CgiProcId,b.CgiProcId);jce_copy_struct(a.FromInfo,b.FromInfo);jce_copy_struct(a.AccIP,b.AccIP);jce_copy_struct(a.AccPort,b.AccPort);jce_copy_struct(a.AccId,b.AccId);jce_copy_struct(a.ClientID,b.ClientID);jce_copy_struct(a.QUAInfo,b.QUAInfo);jce_copy_struct(a.Guid,b.Guid);jce_copy_struct(a.BossReport,b.BossReport);jce_copy_struct(a.Flag,b.Flag);jce_copy_struct(a.Seq,b.Seq);jce_copy_struct(a.extentAccountList,b.extentAccountList);jce_copy_struct(a.AreaCodeInfo,b.AreaCodeInfo);jce_copy_struct(a.HttpCookie,b.HttpCookie);

#define videocomm_HLoginToken_JCE_COPY_STRUCT_HELPER   \
        jce_copy_struct(a.TokenAppID,b.TokenAppID);jce_copy_struct(a.TokenKeyType,b.TokenKeyType);jce_copy_struct(a.TokenValue,b.TokenValue);jce_copy_struct(a.TokenUin,b.TokenUin);jce_copy_struct(a.TokenID,b.TokenID);jce_copy_struct(a.Result,b.Result);jce_copy_struct(a.bMainLogin,b.bMainLogin);

#define videocomm_HttpRequest_JCE_COPY_STRUCT_HELPER   \
        jce_copy_struct(a.ClientIP,b.ClientIP);jce_copy_struct(a.RequestType,b.RequestType);jce_copy_struct(a.Url,b.Url);jce_copy_struct(a.Accept,b.Accept);jce_copy_struct(a.UserAgent,b.UserAgent);jce_copy_struct(a.Host,b.Host);jce_copy_struct(a.Referer,b.Referer);jce_copy_struct(a.PostData,b.PostData);jce_copy_struct(a.Cookies,b.Cookies);jce_copy_struct(a.Queries,b.Queries);jce_copy_struct(a.MoreHeaders,b.MoreHeaders);

#define videocomm_HttpKV_JCE_COPY_STRUCT_HELPER   \
        jce_copy_struct(a.httpKey,b.httpKey);jce_copy_struct(a.httpValue,b.httpValue);

#define videocomm_HttpResponse_JCE_COPY_STRUCT_HELPER   \
        jce_copy_struct(a.HttpActions,b.HttpActions);jce_copy_struct(a.ReturnBody,b.ReturnBody);

#define videocomm_HttpData_JCE_COPY_STRUCT_HELPER   \
        jce_copy_struct(a.Request,b.Request);jce_copy_struct(a.Response,b.Response);

#define videocomm_HAccCmdBody_JCE_COPY_STRUCT_HELPER   \
        jce_copy_struct(a.AccCmd,b.AccCmd);jce_copy_struct(a.AccSubCmd,b.AccSubCmd);jce_copy_struct(a.AccBody,b.AccBody);

#define videocomm_BusinessHead_JCE_COPY_STRUCT_HELPER   \
        jce_copy_struct(a.type,b.type);jce_copy_struct(a.body,b.body);

#define videocomm_VideoCommHeader_JCE_COPY_STRUCT_HELPER   \
        jce_copy_struct(a.BasicInfo,b.BasicInfo);jce_copy_struct(a.AccessInfo,b.AccessInfo);jce_copy_struct(a.LoginTokens,b.LoginTokens);jce_copy_struct(a.body,b.body);jce_copy_struct(a.AccCmdBody,b.AccCmdBody);jce_copy_struct(a.HttpBody,b.HttpBody);jce_copy_struct(a.businessHead,b.businessHead);


